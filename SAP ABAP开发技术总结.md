## **1.1.**  **基本数据类型**

**C、N、D、T、I、F、P、X、string、Xstring**

**P**：默认为8字节，最大允许16字节。最大整数位：16\*2 = 32 - 1 = 31 -14(允许最大小数位数) = 17位整数位

**类型**

**最大长度（字符数）**

**默认长度**

**说明**

**C**

1~262143个字符

1 字符

**N**

1~262143个字符

1 字符

0到9之间字符组成的数字字符串

**D**

8 个字符

日期格式必须为 YYYYMMDD

**T**

6 个字符

格式为 24-hour的 HHMMSS

**I**

4 bytes

\-2.147.483.648 to +2.147.483.647

**F**

8 bytes

小数位最大可以到17位，即可精确到小数点后17位

**P**

1 to 16 bytes

8 bytes

两个数字位压缩后才占一个字节，由于0-9的数字只需要4Bit位，所以一个字节实质上允许存储二位数字，这就是P数据类型为压缩数据类型的由来。并借用半个字节来存储小数点位置、正号、负号相关信息

**X**

1~524,287 bytes

1 byte

十六进制字符 0-9, A-F具体的范围为：00~FF

类型X是十六进制类型，可表示内存字节实际内容，使用两个十六制字符表示一个字节中所存储的内容。但直接打印输出时，输出的还是赋值时字面意义上的值，而不是Unicode解码后的字符

如果未在 DATA 语句中指定参数<length>，则创建长度为1

注：如果值是字母，则一定要**大写**

**1.1.1.**   **P****类型****(****压缩型****)****数据**

是一种压缩的定点数，其数据对象占据内存字节数和数值范围取定义时指定的整个数据大小和小数点后位数，如果不指定小数位，则将视为**I**类型。其有效数字位大小可以是从1~31位数字（小数点与正负号占用一个位置，半个字节），小数点后最多允许14个数字。

P类型的数据，可用于精确运算（这里的精确指的是存储中所存储的数据与定义时字面上所看到的大小相同，而不存在精度丢失问题——看到的就是内存中实实在在的大小）。在使用P类型时，要先选择程序属性中的选项Fixed point arithmetic（即定点算法，一般默认选中），否则系统将P类型看用整型。其效率低于I或F类型。

"16 \* 2 = 32表示了整个字面意义上允许的最大字面个数，而14表示的是字面上小数点后面允许的最大小数位，而不是指14个字节，只有这里定义时的16才表示16个字节

DATA: p(16) TYPE p DECIMALS 14 VALUE '12345678901234567.89012345678901'.

"正负符号与小数点固定要占用半个字节，一个字面上位置，并包括在这16个字节里面。  
"16 \* 2 = 32位包括了小数点与在正负号在内  
"在定义时字面上允许最长可以达到32位，除去小数点与符号需占半个字节以后  
"有效数字位可允许31位，这31位中包括了整数位与小数位，再除去定义时小  
"数位为14位外，整数位最多还可达到17位，所以下面最多只能是17个9  
DATA: p1(16) TYPE p DECIMALS 14 VALUE '-99999999999999999'.

"P类型是以字符串来表示一个数的，与字符串不一样的是，P类型中的每个数字位只会占用4Bit位，所以两个数字位才会占用一个字节。另外，如果定义时没有指定小数位，表示是整型，但小数点固定要占用半个字节，所以不带小数位与符号的最大与最小整数如下（最多允许31个9，而不是32个）  
DATA: p1(16) TYPE p  VALUE '+9999999999999999999999999999999'.  
DATA: p2(16) TYPE p  VALUE '-9999999999999999999999999999999'.

其实P类型是以字符串形式来表示一个小数，这样才可以作到精确，就像Java中要表示一个精确的小数要使用BigDecimal一样，否则会丢失精度。

DATA: p(9) TYPE p DECIMALS 2 VALUE '-123456789012345.12'.  
WRITE: / p."123456789012345.12-

DATA: f1 TYPE f VALUE '2.0',  
      f2 TYPE f VALUE '1.1',  
      f3 TYPE f.  
f3  \=  f1 \- f2."不能精确计算  
"2.0000000000000000E+00 1.1000000000000001E+00 8.9999999999999991E-01  
WRITE: / f1   , f2 , f3.  
  
DATA: p1 TYPE p DECIMALS 1 VALUE '2.0',  
      p2 TYPE p DECIMALS 1 VALUE '1.1',  
      p3 TYPE p DECIMALS 1.  
p3  \=  p1 \- p2."能精确计算  
WRITE: / p1   , p2 , p3. "2.0               1.1               0.9

**Java****中精确计算：**

    **publicstaticvoid** main(String\[\] args) {

        System.out.println(2.0 - 1.1);// 0.8999999999999999

        System.*out*.println(*sub*(2.0, 0.1));// 1.9

    }

    **publicstaticdouble** sub(**double** v1, **double** v2) {

        BigDecimal b1 = **new** BigDecimal(Double.*toString*(v1));

        BigDecimal b2 = **new** BigDecimal(Double.*toString*(v2));

        **return** b1.subtract(b2).doubleValue();

    }